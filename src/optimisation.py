import os, re
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from textwrap import wrap



old_seq = 'ATGGGGCAAACTAAAAGTAAAATTAAAAGTAAATATGCCTCTTATCTCAGCTTTATTAAAATTCTTTTAAAAAGAGGGGGAGTTAAAGTATCTACAAAAAATCTAATCAAGCTATTTCAAATAATAGAACAATTTTGCCCATGGTTTCCAGAACAAGGAACTTTAGATCTAAAAGATTGGAAAAGAATTGGTAAGGAACTAAAACAAGCAGGTAGGAAGGGTAATATCATTCCACTTACAGTATGGAATGATTGGGCCATTATTAAAGCAGCTTTAGAACCATTTCAAACAGAAGAAGATAGCGTTTCAGTTTCTGATGCCCCTGGAAGCTGTATAATAGATTGTAATGAAAACACAAGGAAAAAATCCCAGAAAGAAACGGAAGGTTTACATTGCGAATATGTAGCAGAGCCGGTAATGGCTCAGTCAACGCAAAATGTTGACTATAATCAATTACAGGAGGTGATATATCCTGAAACGTTAAAATTAGAAGGAAAAGGTCCAGAATTAGTGGGGCCATCAGAGTCTAAACCACGAGGCACAAGTCCTCTTCCAGCAGGTCAGGTGCCCGTAACATTACAACCTCAAAAGCAGGTTAAAGAAAATAAGACCCAACCGCCAGTAGCCTATCAATACTGGCCTCCGGCTGAACTTCAGTATCGGCCACCCCCAGAAAGTCAGTATGGATATCCAGGAATGCCCCCAGCACCACAGGGCAGGGCGCCATACCCTCAGCCGCCCACTAGGAGACTTAATCCTACGGCACCACCTAGTAGACAGGGTAGTGAATTACATGAAATTATTGATAAATCAAGAAAGGAAGGAGATACTGAGGCATGGCAATTCCCAGTAACGTTAGAACCGATGCCACCTGGAGAAGGAGCCCAAGAGGGAGAGCCTCCCACAGTTGAGGCCAGATACAAGTCTTTTTCGATAAAAATGCTAAAAGATATGAAAGAGGGAGTAAAACAGTATGGACCCAACTCCCCTTATATGAGGACATTATTAGATTCCATTGCTCATGGACATAGACTCATTCCTTATGATTGGGAGATTCTGGCAAAATCGTCTCTCTCACCCTCTCAATTTTTACAATTTAAGACTTGGTGGATTGATGGGGTACAAGAACAGGTCCGAAGAAATAGGGCTGCCAATCCTCCAGTTAACATAGATGCAGATCAACTATTAGGAATAGGTCAAAATTGGAGTACTATTAGTCAACAAGCATTAATGCAAAATGAGGCCATTGAGCAAGTTAGAGCTATCTGCCTTAGAGCCTGGGAAAAAATCCAAGACCCAGGAAGTACCTGCCCCTCATTTAATACAGTAAGACAAGGTTCAAAAGAGCCCTATCCTGATTTTGTGGCAAGGCTCCAAGATGTTGCTCAAAAGTCAATTGCCGATGAAAAAGCCCGTAAGGTCATAGTGGAGTTGATGGCATATGAAAACGCCAATCCTGAGTGTCAATCAGCCATTAAGCCATTAAAAGGAAAGGTTCCTGCAGGATCAGATGTAATCTCAGAATATGTAAAAGCCTGTGATGGAATCGGAGGAGCTATGCATAAAGCTATGCTTATGGCTCAAGCAATAACAGGAGTTGTTTTAGGAGGACAAGTTAGAACATTTGGAGGAAAATGTTATAATTGTGGTCAAATTGGTCACTTAAAAAAGAATTGCCCAGTCTTAAACAAACAGAATATAACTATTCAAGCAACTACAACAGGTAGAGAGCCACCTGACTTATGTCCAAGATGTAAAAAAGGAAAACATTGGGCTAGTCAATGTCGTTCTAAATTTGATAAAAATGGGCAACCATTGTCGGGAAACGAGCAAAGGGGCCAGCCTCAGGCCCCACAACAAACTGGGGCATTCCCAATTCAGCCATTTGTTCCTCAGGGTTTTCAGGGACAACAACCCCCACTGTCCCAAGTGTTTCAGGGAATAAGCCAGTTACCACAATACAACAATTGTCCCCCGCCACAAGCGGCAGTGCAGCAGTAG'
new_seq = 'ATGGGCCAGACCAAGAGCAAGATCAAAAGCAAGTACGCCAGCTACCTGAGCTTCATCAAGATCCTGCTGAAGAGAGGCGGAGTGAAAGTGAGCACCAAGAATCTGATCAAGCTCTTCCAGATCATCGAGCAGTTTTGCCCCTGGTTCCCTGAGCAGGGCACCCTGGATCTGAAGGACTGGAAGCGGATCGGCAAAGAACTGAAGCAGGCCGGCCGGAAGGGCAACATCATCCCTCTTACAGTGTGGAACGACTGGGCCATCATCAAGGCCGCCCTGGAACCTTTCCAGACAGAGGAAGATAGCGTGTCTGTCAGCGATGCCCCTGGAAGCTGCATCATTGATTGCAACGAAAACACCAGAAAGAAGAGTCAGAAGGAAACCGAGGGCCTGCACTGCGAGTACGTGGCAGAACCTGTCATGGCCCAGAGCACCCAGAACGTGGACTACAACCAGCTGCAGGAGGTGATTTACCCCGAGACTCTGAAGCTGGAAGGTAAAGGCCCCGAACTGGTGGGCCCTTCTGAAAGCAAGCCGCGGGGCACCAGCCCCCTGCCTGCTGGCCAAGTGCCCGTGACCCTCCAACCTCAAAAGCAGGTCAAGGAAAACAAGACCCAGCCCCCTGTGGCCTATCAGTACTGGCCTCCCGCCGAGCTACAGTATAGACCTCCACCTGAGAGCCAGTACGGATACCCCGGCATGCCTCCAGCTCCTCAAGGACGCGCCCCTTACCCTCAGCCTCCCACCAGAAGACTGAACCCCACCGCCCCTCCAAGCAGACAGGGCTCTGAACTGCACGAGATCATCGATAAGTCCCGGAAGGAGGGCGACACCGAGGCCTGGCAGTTCCCCGTGACATTGGAACCTATGCCCCCCGGCGAGGGCGCCCAGGAGGGAGAGCCTCCTACAGTTGAGGCCAGATACAAGAGCTTCTCCATCAAGATGCTGAAAGATATGAAAGAAGGCGTGAAACAGTACGGCCCTAACAGCCCTTACATGAGAACACTGCTGGACTCTATCGCCCACGGCCACAGACTGATCCCCTACGACTGGGAAATCCTGGCCAAGTCTTCTCTCTCTCCTAGTCAGTTCCTGCAGTTCAAGACCTGGTGGATCGACGGCGTCCAGGAGCAGGTGCGGCGGAACAGAGCCGCTAATCCTCCTGTGAACATCGACGCCGACCAGCTGCTGGGCATCGGCCAGAATTGGAGCACCATCAGCCAGCAGGCCCTGATGCAGAATGAGGCCATCGAGCAGGTGAGGGCCATCTGCCTGAGAGCATGGGAGAAAATCCAAGACCCCGGCAGCACATGCCCTAGCTTCAACACCGTGCGGCAGGGCAGCAAGGAACCATATCCTGACTTCGTGGCCCGGCTGCAGGACGTGGCCCAGAAGTCCATCGCCGATGAGAAGGCCAGAAAAGTGATCGTGGAACTGATGGCTTACGAGAACGCCAATCCTGAGTGCCAGTCCGCCATCAAGCCCCTGAAAGGCAAGGTGCCAGCTGGCAGCGATGTGATCTCTGAGTACGTGAAGGCCTGCGACGGAATCGGCGGTGCTATGCACAAGGCTATGCTGATGGCCCAGGCCATTACAGGAGTGGTGCTGGGCGGCCAGGTACGGACCTTCGGCGGAAAGTGCTACAACTGTGGCCAGATCGGCCATCTGAAGAAAAACTGTCCCGTGCTGAACAAGCAAAACATCACAATCCAGGCTACAACCACAGGCAGAGAGCCTCCAGACCTGTGCCCAAGATGTAAAAAGGGCAAGCACTGGGCTAGCCAGTGTAGAAGCAAATTCGACAAGAATGGTCAGCCTCTGTCCGGCAACGAGCAAAGAGGCCAGCCACAAGCCCCCCAACAGACCGGCGCTTTTCCTATCCAGCCCTTCGTGCCTCAGGGATTTCAGGGCCAGCAGCCTCCTCTGAGCCAGGTGTTTCAGGGAATTTCTCAGCTGCCCCAATACAACAACTGCCCTCCTCCCCAGGCTGCCGTGCAGCAGTGA'

# Break into codons
old_codons = pd.DataFrame(wrap(old_seq, 3), columns=['original_codon'])
new_codons = pd.DataFrame(wrap(new_seq, 3), columns=['new_codon'])

codons = pd.merge(old_codons, new_codons, left_index=True, right_index=True)

# Calculate the matching condons and nucleotides

def calculate_identity(codons):
    codons['codon_identity'] = [1 if old == new else 0 for old, new in codons[['original_codon', 'new_codon']].values]
    codon_identity = codons['codon_identity'].sum() / len(codons) * 100

    nt_identities = []
    for old, new in codons[['original_codon', 'new_codon']].values:
        if old == new:
            nt_identities.append(3)
        else:
            nt_identity = 0
            for nt_old, nt_new in zip(old, new):
                if nt_old == nt_new:
                    nt_identity += 1
        
            nt_identities.append(nt_identity)
    codons['nucleotide_identity'] = nt_identities
    
    return codons

codons = calculate_identity(codons)

# Visualise overlap in old and new sequences
def plot_identity():
    fig, ax = plt.subplots(figsize=(20, 5))
    plt.stem(range(len(codons)), codons['nucleotide_identity'])
    plt.xlabel('Position')
    
    return fig

plot_identity()

# Filter identical nucleotides
identical_nucs = codons[codons['nucleotide_identity'] == 3].copy()

# Check for clusters of identical sequence - modify at least every second codon in a cluster using a random codon

# Recalculate identity with updated codons

# Compare codon usage to optimal frequency
# -> add optimal frequencies to the codon-table.csv as a new column
# -> calculate frequency usage in both GenScript and randomised sequences
# -> Visualise difference in optimal for each amino acid 